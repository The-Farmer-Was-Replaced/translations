# Name Scopes
Области видимости определяют, какие переменные могут быть доступны откуда. Область видимости — это, по сути, отображение от имен к значениям.
Они работают почти так же, как в Python, но не всегда, поэтому обязательно внимательно прочитайте этот раздел.

Как и в Python, существует глобальная область видимости, и каждая функция имеет локальную область видимости.
Когда вы определяете переменную, она добавляется в текущую область видимости.
Все, что находится вне определения функции, считается частью глобальной области видимости.

`x = 1`
Присваивает значение `1` имени `x` в глобальной области видимости.

Этот оператор `def` присваивает функцию имени `f` в глобальной области видимости.
`def f():
    `Присваивает значение `1` имени `y` в локальной области видимости `f`.`
    y = 1

    `Присваивает функцию имени `g` в локальной области видимости `f`.`
    def g():
        pass`

`f()`
Извлекает функцию, хранящуюся в `f`, из глобальной области видимости и вызывает ее.

`print(y)`
Этот оператор print в глобальной области видимости вызывает ошибку, потому что `y` никогда не объявлялась в глобальной области видимости, поэтому мы не можем ее здесь прочитать.
Она существовала только в локальной области видимости `f`.

Циклы и ветвления не создают свои собственные области видимости, поэтому все, что объявлено внутри них, все еще может быть использовано снаружи.

`for i in range(3):
    pass
print(i)`

Это выведет `2`, потому что последняя итерация цикла `for` присвоила `2` переменной `i`.

Все до этого момента такое же, как в Python. Первое различие заключается в том, как глобальные определения из других файлов импортируются. Python использует оператор import для этого, игра автоматически импортирует глобальные функции.

Любые функции, определенные в загруженных файлах, будут добавлены в глобальную область видимости перед выполнением, поэтому вы можете использовать функции, объявленные в других файлах.
Обратите внимание, что это не относится к глобальным переменным. Они доступны только тогда, когда строка, в которой они присваиваются, фактически выполняется. Выполняется только глобальная область видимости окна, на которое вы нажимаете кнопку выполнения.

Переменные из глобальной области видимости могут быть прочитаны в любом месте, но присваивания всегда будут присваивать в локальную область видимости.

`x = 1

def f():
    x += 1

f()

print(x)`

Этот код выводит `1`, а не `2`, потому что `x += 1` сначала прочитает `1` из глобальной переменной `x`, а затем присвоит `2` новой локальной переменной, которая также называется `x`.
Таким образом, глобальная переменная `x` никогда не изменяется.

Это поведение немного отличается от поведения Python.
Python вызывает здесь ошибку, потому что вы пытаетесь прочитать из локальной переменной до того, как она присвоена.

В Python также можно использовать ключевое слово 'global', чтобы объявить, что вы хотите использовать глобальную переменную вместо локальной, но это не поддерживается в этой игре.

Если вам действительно нужно обновить глобальные переменные, вы можете использовать для этого словарь.
Они используют семантику ссылок, что означает, что переменная содержит ссылку на базовый словарь, а не хранит структуру данных непосредственно в переменной.
Глобальная переменная может хранить ссылку на словарь, который можно прочитать в функции.
Вы можете изменить базовый словарь, не обновляя переменную в глобальной области видимости.
Поскольку переменная в глобальной области видимости все еще указывает на тот же словарь, она также отразит любые изменения, внесенные в этот словарь. Чтобы проиллюстрировать, рассмотрим следующий код:

Присвоить словарь в глобальной области видимости
`d = {"x": 1}

def f():
    `внести изменение в словарь, на который ссылается `d`.`
    d["x"] += 1

`выводит `2
print(d["x"])`
